const mongoose = require('mongoose');
const { ALERT_SEVERITY, ALERT_TYPES } = require('../config/constants');

const AlertSchema = new mongoose.Schema({
    type: {
        type: String,
        required: [true, 'Alert type is required'],
        enum: Object.values(ALERT_TYPES)
    },
    severity: {
        type: String,
        required: [true, 'Alert severity is required'],
        enum: Object.values(ALERT_SEVERITY),
        default: ALERT_SEVERITY.MEDIUM
    },
    title: {
        type: String,
        required: [true, 'Alert title is required'],
        trim: true,
        maxlength: [200, 'Title cannot be more than 200 characters']
    },
    message: {
        type: String,
        required: [true, 'Alert message is required'],
        trim: true
    },
    deviceId: {
        type: String,
        default: 'ESP32_SOLAR_01',
        trim: true
    },
    sensorDataId: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'SensorData'
    },
    sensorValue: {
        type: Number,
        required: [true, 'Sensor value is required']
    },
    threshold: {
        type: Number
    },
    unit: {
        type: String,
        trim: true
    },
    location: {
        type: String,
        default: 'Kadidi Health Center',
        trim: true
    },
    acknowledged: {
        type: Boolean,
        default: false
    },
    acknowledgedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    acknowledgedAt: {
        type: Date
    },
    resolved: {
        type: Boolean,
        default: false
    },
    resolvedBy: {
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    },
    resolvedAt: {
        type: Date
    },
    resolutionNotes: {
        type: String,
        trim: true,
        maxlength: [500, 'Resolution notes cannot be more than 500 characters']
    },
    emailSent: {
        type: Boolean,
        default: false
    },
    emailSentAt: {
        type: Date
    },
    smsSent: {
        type: Boolean,
        default: false
    },
    smsSentAt: {
        type: Date
    },
    notificationSentTo: [{
        type: mongoose.Schema.Types.ObjectId,
        ref: 'User'
    }],
    autoGenerated: {
        type: Boolean,
        default: true
    },
    metadata: {
        previousValue: Number,
        rateOfChange: Number,
        duration: Number, // How long the condition has existed
        relatedAlerts: [{
            type: mongoose.Schema.Types.ObjectId,
            ref: 'Alert'
        }]
    }
}, {
    timestamps: true,
    toJSON: { virtuals: true },
    toObject: { virtuals: true }
});

// Virtual for formatted time since creation
AlertSchema.virtual('timeAgo').get(function() {
    const seconds = Math.floor((Date.now() - this.createdAt) / 1000);
    
    let interval = Math.floor(seconds / 31536000);
    if (interval >= 1) return interval + ' year' + (interval > 1 ? 's' : '') + ' ago';
    
    interval = Math.floor(seconds / 2592000);
    if (interval >= 1) return interval + ' month' + (interval > 1 ? 's' : '') + ' ago';
    
    interval = Math.floor(seconds / 86400);
    if (interval >= 1) return interval + ' day' + (interval > 1 ? 's' : '') + ' ago';
    
    interval = Math.floor(seconds / 3600);
    if (interval >= 1) return interval + ' hour' + (interval > 1 ? 's' : '') + ' ago';
    
    interval = Math.floor(seconds / 60);
    if (interval >= 1) return interval + ' minute' + (interval > 1 ? 's' : '') + ' ago';
    
    return 'just now';
});

// Virtual for priority (based on severity and age)
AlertSchema.virtual('priority').get(function() {
    let priority = 0;
    
    // Base priority on severity
    switch (this.severity) {
        case ALERT_SEVERITY.CRITICAL: priority += 100; break;
        case ALERT_SEVERITY.HIGH: priority += 75; break;
        case ALERT_SEVERITY.MEDIUM: priority += 50; break;
        case ALERT_SEVERITY.LOW: priority += 25; break;
    }
    
    // Increase priority if not acknowledged
    if (!this.acknowledged) priority += 30;
    
    // Increase priority with age (if not resolved)
    if (!this.resolved) {
        const hoursSinceCreation = (Date.now() - this.createdAt) / (1000 * 3600);
        priority += Math.min(hoursSinceCreation * 2, 50); // Max 50 points for age
    }
    
    return Math.min(priority, 100); // Cap at 100
});

// Pre-save middleware to update resolvedAt if resolved
AlertSchema.pre('save', function(next) {
    if (this.isModified('resolved') && this.resolved && !this.resolvedAt) {
        this.resolvedAt = new Date();
    }
    
    if (this.isModified('acknowledged') && this.acknowledged && !this.acknowledgedAt) {
        this.acknowledgedAt = new Date();
    }
    
    next();
});

// Static method to get active alerts
AlertSchema.statics.getActiveAlerts = function(severity = null) {
    const query = { resolved: false };
    if (severity) query.severity = severity;
    
    return this.find(query)
        .sort({ createdAt: -1 })
        .populate('acknowledgedBy', 'name email')
        .populate('resolvedBy', 'name email');
};

// Static method to get alerts by date range
AlertSchema.statics.getAlertsByDateRange = function(startDate, endDate) {
    return this.find({
        createdAt: { $gte: startDate, $lte: endDate }
    })
    .sort({ createdAt: -1 })
    .populate('acknowledgedBy', 'name')
    .populate('resolvedBy', 'name');
};

// Static method to get alert statistics
AlertSchema.statics.getStatistics = async function(days = 30) {
    const startDate = new Date();
    startDate.setDate(startDate.getDate() - days);
    
    const alerts = await this.find({
        createdAt: { $gte: startDate }
    });
    
    const stats = {
        total: alerts.length,
        bySeverity: {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0
        },
        byType: {},
        acknowledged: 0,
        resolved: 0,
        avgResolutionTime: 0,
        recentTrend: 'stable'
    };
    
    let totalResolutionTime = 0;
    let resolvedCount = 0;
    
    alerts.forEach(alert => {
        // Count by severity
        stats.bySeverity[alert.severity] = (stats.bySeverity[alert.severity] || 0) + 1;
        
        // Count by type
        stats.byType[alert.type] = (stats.byType[alert.type] || 0) + 1;
        
        // Count acknowledged and resolved
        if (alert.acknowledged) stats.acknowledged++;
        if (alert.resolved) {
            stats.resolved++;
            if (alert.resolvedAt && alert.createdAt) {
                totalResolutionTime += alert.resolvedAt - alert.createdAt;
                resolvedCount++;
            }
        }
    });
    
    // Calculate average resolution time in hours
    if (resolvedCount > 0) {
        stats.avgResolutionTime = Math.round((totalResolutionTime / resolvedCount) / (1000 * 3600));
    }
    
    // Calculate recent trend (last 7 days vs previous 7 days)
    const weekAgo = new Date();
    weekAgo.setDate(weekAgo.getDate() - 7);
    
    const twoWeeksAgo = new Date();
    twoWeeksAgo.setDate(twoWeeksAgo.getDate() - 14);
    
    const recentAlerts = await this.countDocuments({
        createdAt: { $gte: weekAgo }
    });
    
    const previousAlerts = await this.countDocuments({
        createdAt: { $gte: twoWeeksAgo, $lt: weekAgo }
    });
    
    if (previousAlerts === 0) {
        stats.recentTrend = 'stable';
    } else {
        const change = ((recentAlerts - previousAlerts) / previousAlerts) * 100;
        if (change > 20) stats.recentTrend = 'increasing';
        else if (change < -20) stats.recentTrend = 'decreasing';
        else stats.recentTrend = 'stable';
    }
    
    return stats;
};

// Static method to acknowledge multiple alerts
AlertSchema.statics.acknowledgeAlerts = function(alertIds, userId) {
    return this.updateMany(
        { _id: { $in: alertIds } },
        {
            $set: {
                acknowledged: true,
                acknowledgedBy: userId,
                acknowledgedAt: new Date()
            }
        }
    );
};

// Static method to resolve multiple alerts
AlertSchema.statics.resolveAlerts = function(alertIds, userId, notes = '') {
    return this.updateMany(
        { _id: { $in: alertIds } },
        {
            $set: {
                resolved: true,
                resolvedBy: userId,
                resolvedAt: new Date(),
                resolutionNotes: notes
            }
        }
    );
};

// Method to get similar unresolved alerts
AlertSchema.methods.findSimilarAlerts = function(hours = 24) {
    const cutoff = new Date(Date.now() - hours * 60 * 60 * 1000);
    
    return this.constructor.find({
        _id: { $ne: this._id },
        type: this.type,
        resolved: false,
        createdAt: { $gte: cutoff }
    });
};

// Indexes for performance
AlertSchema.index({ createdAt: -1 });
AlertSchema.index({ severity: 1, createdAt: -1 });
AlertSchema.index({ type: 1, createdAt: -1 });
AlertSchema.index({ resolved: 1, acknowledged: 1 });
AlertSchema.index({ deviceId: 1, createdAt: -1 });
AlertSchema.index({ sensorDataId: 1 });
AlertSchema.index({ acknowledgedBy: 1 });
AlertSchema.index({ resolvedBy: 1 });
AlertSchema.index({ priority: -1 }); // Virtual index (not stored)

// TTL index to automatically delete old alerts after 90 days
AlertSchema.index({ createdAt: 1 }, { 
    expireAfterSeconds: 90 * 24 * 60 * 60 // 90 days
});

const Alert = mongoose.model('Alert', AlertSchema);

module.exports = Alert;