const { Report, SensorData, User } = require('../models');
const ReportGenerator = require('../utils/reportGenerator');
const EmailService = require('../utils/emailService');
const Helpers = require('../utils/helpers');
const { USER_ROLES, REPORT_TYPES } = require('../config/constants');
const fs = require('fs');
const path = require('path');

class ReportController {
    // Render reports page
    static async renderReports(req, res) {
        try {
            const { type, page = 1 } = req.query;
            
            // Build query
            const query = {};
            
            if (type && Object.values(REPORT_TYPES).includes(type)) {
                query.type = type;
            }
            
            // Only show public reports or reports generated by user
            if (req.session.user.role !== USER_ROLES.ADMIN) {
                query.$or = [
                    { isPublic: true },
                    { generatedBy: req.session.user.id },
                    { sharedWith: req.session.user.id }
                ];
            }
            
            // Pagination
            const pageSize = 10;
            const skip = (parseInt(page) - 1) * pageSize;
            
            // Get total count
            const total = await Report.countDocuments(query);
            
            // Get reports
            const reports = await Report.find(query)
                .sort({ 'period.endDate': -1 })
                .skip(skip)
                .limit(pageSize)
                .populate('generatedBy', 'name email');
            
            // Calculate pagination
            const totalPages = Math.ceil(total / pageSize);
            const pagination = Helpers.createPagination(total, parseInt(page), pageSize);
            
            // Get report statistics
            const stats = await Report.getStatistics();
            
            res.render('pages/reports', {
                title: 'Reports - Solar Monitoring System',
                user: req.session.user,
                reports,
                pagination,
                stats,
                filters: { type },
                reportTypes: REPORT_TYPES,
                helpers: Helpers,
                success: req.query.success || null,
                error: req.query.error || null
            });
            
        } catch (error) {
            console.error('Render reports error:', error);
            res.status(500).render('pages/reports', {
                title: 'Reports - Solar Monitoring System',
                user: req.session.user,
                reports: [],
                pagination: null,
                stats: null,
                filters: {},
                reportTypes: REPORT_TYPES,
                helpers: Helpers,
                success: null,
                error: 'Failed to load reports'
            });
        }
    }
    
    // Generate report (API)
    static async generateReport(req, res) {
        try {
            const {
                type = REPORT_TYPES.DAILY,
                format = 'pdf',
                startDate,
                endDate,
                includeRawData = false,
                emailRecipients = []
            } = req.body;
            
            const userId = req.session.user.id;
            
            // Validate dates
            let reportStartDate, reportEndDate;
            
            if (startDate && endDate) {
                reportStartDate = new Date(startDate);
                reportEndDate = new Date(endDate);
                
                if (reportStartDate > reportEndDate) {
                    return res.status(400).json({
                        success: false,
                        message: 'Start date must be before end date'
                    });
                }
            } else {
                // Use default dates based on type
                const now = new Date();
                
                switch (type) {
                    case REPORT_TYPES.DAILY:
                        reportStartDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                        reportEndDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 23, 59, 59);
                        break;
                    case REPORT_TYPES.WEEKLY:
                        reportStartDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 7);
                        reportEndDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 23, 59, 59);
                        break;
                    case REPORT_TYPES.MONTHLY:
                        reportStartDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
                        reportEndDate = new Date(now.getFullYear(), now.getMonth(), 0, 23, 59, 59);
                        break;
                    default:
                        reportStartDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
                        reportEndDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 23, 59, 59);
                }
            }
            
            // Get sensor data for the period
            const sensorData = await SensorData.getRange(reportStartDate, reportEndDate);
            
            if (sensorData.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'No data available for the specified period'
                });
            }
            
            // Generate report
            const reportResult = await ReportGenerator.generateReport(
                sensorData,
                reportStartDate,
                reportEndDate,
                {
                    type,
                    format,
                    includeRawData
                }
            );
            
            // Create report document
            const report = new Report({
                title: Report.generateTitle(type, reportStartDate, reportEndDate),
                type,
                period: {
                    startDate: reportStartDate,
                    endDate: reportEndDate
                },
                generatedBy: userId,
                filePath: reportResult.filePath,
                fileName: reportResult.fileName,
                fileSize: reportResult.fileSize,
                format: reportResult.format,
                summary: reportResult.summary,
                metadata: {
                    generationTime: 0, // Would calculate actual generation time
                    dataPointsUsed: sensorData.length,
                    chartsIncluded: true,
                    recommendationsCount: 0,
                    anomaliesDetected: 0
                },
                isPublic: req.session.user.role === USER_ROLES.ADMIN
            });
            
            await report.save();
            
            // Send email if recipients specified
            if (emailRecipients && emailRecipients.length > 0 && reportResult.filePath) {
                try {
                    for (const email of emailRecipients) {
                        await EmailService.sendReportEmail(
                            email,
                            reportResult.filePath,
                            type
                        );
                    }
                    
                    report.emailSent = true;
                    report.emailSentTo = emailRecipients;
                    report.emailSentAt = new Date();
                    await report.save();
                } catch (emailError) {
                    console.error('Failed to send report email:', emailError);
                    // Don't fail report generation if email fails
                }
            }
            
            // Increment download count
            await Report.incrementDownload(report._id);
            
            res.json({
                success: true,
                message: 'Report generated successfully',
                data: {
                    reportId: report._id,
                    title: report.title,
                    filePath: report.filePath,
                    fileName: report.fileName,
                    downloadUrl: `/api/reports/download/${report._id}`,
                    previewUrl: `/api/reports/preview/${report._id}`,
                    generatedAt: report.createdAt
                }
            });
            
        } catch (error) {
            console.error('Generate report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to generate report',
                error: error.message
            });
        }
    }
    
    // Download report (API)
    static async downloadReport(req, res) {
        try {
            const { id } = req.params;
            
            const report = await Report.findById(id);
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            // Check permissions
            if (!report.isPublic && 
                report.generatedBy.toString() !== req.session.user.id &&
                !report.sharedWith.includes(req.session.user.id) &&
                req.session.user.role !== USER_ROLES.ADMIN) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied to this report'
                });
            }
            
            // Check if file exists
            const filePath = path.join(__dirname, '../../', report.filePath);
            
            if (!fs.existsSync(filePath)) {
                return res.status(404).json({
                    success: false,
                    message: 'Report file not found'
                });
            }
            
            // Increment download count
            await Report.incrementDownload(id);
            
            // Set headers for download
            res.setHeader('Content-Type', report.getMimeType());
            res.setHeader('Content-Disposition', `attachment; filename="${report.fileName}"`);
            
            // Stream file
            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);
            
        } catch (error) {
            console.error('Download report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to download report',
                error: error.message
            });
        }
    }
    
    // Preview report (API)
    static async previewReport(req, res) {
        try {
            const { id } = req.params;
            
            const report = await Report.findById(id);
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            // Check permissions
            if (!report.isPublic && 
                report.generatedBy.toString() !== req.session.user.id &&
                !report.sharedWith.includes(req.session.user.id) &&
                req.session.user.role !== USER_ROLES.ADMIN) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied to this report'
                });
            }
            
            // Only PDF can be previewed
            if (report.format !== 'pdf') {
                return res.status(400).json({
                    success: false,
                    message: 'Only PDF reports can be previewed'
                });
            }
            
            // Check if file exists
            const filePath = path.join(__dirname, '../../', report.filePath);
            
            if (!fs.existsSync(filePath)) {
                return res.status(404).json({
                    success: false,
                    message: 'Report file not found'
                });
            }
            
            // Set headers for inline viewing
            res.setHeader('Content-Type', 'application/pdf');
            res.setHeader('Content-Disposition', `inline; filename="${report.fileName}"`);
            
            // Stream file
            const fileStream = fs.createReadStream(filePath);
            fileStream.pipe(res);
            
        } catch (error) {
            console.error('Preview report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to preview report',
                error: error.message
            });
        }
    }
    
    // Get report by ID (API)
    static async getReportById(req, res) {
        try {
            const { id } = req.params;
            
            const report = await Report.findById(id)
                .populate('generatedBy', 'name email')
                .populate('sharedWith', 'name email');
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            // Check permissions
            if (!report.isPublic && 
                report.generatedBy.toString() !== req.session.user.id &&
                !report.sharedWith.includes(req.session.user.id) &&
                req.session.user.role !== USER_ROLES.ADMIN) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied to this report'
                });
            }
            
            res.json({
                success: true,
                data: report
            });
            
        } catch (error) {
            console.error('Get report by ID error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to get report',
                error: error.message
            });
        }
    }
    
    // Get reports with filters (API)
    static async getReports(req, res) {
        try {
            const {
                type,
                startDate,
                endDate,
                format,
                limit = 20,
                page = 1,
                sort = '-period.endDate'
            } = req.query;
            
            // Build query
            const query = {};
            
            if (type && Object.values(REPORT_TYPES).includes(type)) {
                query.type = type;
            }
            
            if (format) {
                query.format = format;
            }
            
            // Date range
            if (startDate || endDate) {
                query['period.startDate'] = {};
                if (startDate) query['period.startDate'].$gte = new Date(startDate);
                if (endDate) query['period.startDate'].$lte = new Date(endDate);
            }
            
            // Only show public reports or reports generated by user
            if (req.session.user.role !== USER_ROLES.ADMIN) {
                query.$or = [
                    { isPublic: true },
                    { generatedBy: req.session.user.id },
                    { sharedWith: req.session.user.id }
                ];
            }
            
            // Pagination
            const pageSize = parseInt(limit);
            const skip = (parseInt(page) - 1) * pageSize;
            
            // Get total count
            const total = await Report.countDocuments(query);
            
            // Get reports
            const reports = await Report.find(query)
                .sort(sort)
                .skip(skip)
                .limit(pageSize)
                .populate('generatedBy', 'name email');
            
            // Calculate pagination metadata
            const totalPages = Math.ceil(total / pageSize);
            const pagination = Helpers.createPagination(total, parseInt(page), pageSize);
            
            res.json({
                success: true,
                pagination,
                count: reports.length,
                total,
                data: reports
            });
            
        } catch (error) {
            console.error('Get reports error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to get reports',
                error: error.message
            });
        }
    }
    
    // Update report (admin only - API)
    static async updateReport(req, res) {
        try {
            const { id } = req.params;
            const { title, isPublic, tags, sharedWith } = req.body;
            
            // Check if user is admin or report owner
            const report = await Report.findById(id);
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            if (req.session.user.role !== USER_ROLES.ADMIN && 
                report.generatedBy.toString() !== req.session.user.id) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Only admin or report owner can update.'
                });
            }
            
            // Update fields
            if (title) report.title = title;
            if (typeof isPublic === 'boolean') report.isPublic = isPublic;
            if (tags && Array.isArray(tags)) report.tags = tags;
            
            if (sharedWith && Array.isArray(sharedWith)) {
                // Validate user IDs
                const validUsers = await User.find({ _id: { $in: sharedWith } });
                report.sharedWith = validUsers.map(user => user._id);
            }
            
            await report.save();
            
            res.json({
                success: true,
                message: 'Report updated successfully',
                data: report
            });
            
        } catch (error) {
            console.error('Update report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to update report',
                error: error.message
            });
        }
    }
    
    // Delete report (admin only - API)
    static async deleteReport(req, res) {
        try {
            const { id } = req.params;
            
            // Check if user is admin
            if (req.session.user.role !== USER_ROLES.ADMIN) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Admin privileges required.'
                });
            }
            
            const report = await Report.findById(id);
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            // Delete file from filesystem
            const filePath = path.join(__dirname, '../../', report.filePath);
            if (fs.existsSync(filePath)) {
                fs.unlinkSync(filePath);
            }
            
            await report.deleteOne();
            
            res.json({
                success: true,
                message: 'Report deleted successfully'
            });
            
        } catch (error) {
            console.error('Delete report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to delete report',
                error: error.message
            });
        }
    }
    
    // Send report via email (API)
    static async sendReportEmail(req, res) {
        try {
            const { id } = req.params;
            const { emails } = req.body;
            
            if (!emails || !Array.isArray(emails) || emails.length === 0) {
                return res.status(400).json({
                    success: false,
                    message: 'Please provide email addresses'
                });
            }
            
            const report = await Report.findById(id);
            
            if (!report) {
                return res.status(404).json({
                    success: false,
                    message: 'Report not found'
                });
            }
            
            // Check permissions
            if (req.session.user.role !== USER_ROLES.ADMIN && 
                report.generatedBy.toString() !== req.session.user.id) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Only admin or report owner can send emails.'
                });
            }
            
            // Check if file exists
            const filePath = path.join(__dirname, '../../', report.filePath);
            
            if (!fs.existsSync(filePath)) {
                return res.status(404).json({
                    success: false,
                    message: 'Report file not found'
                });
            }
            
            // Send emails
            const sentEmails = [];
            const failedEmails = [];
            
            for (const email of emails) {
                try {
                    await EmailService.sendReportEmail(email, filePath, report.type);
                    sentEmails.push(email);
                } catch (emailError) {
                    console.error(`Failed to send email to ${email}:`, emailError);
                    failedEmails.push({ email, error: emailError.message });
                }
            }
            
            // Update report
            report.emailSent = true;
            report.emailSentTo = [...new Set([...(report.emailSentTo || []), ...sentEmails])];
            report.emailSentAt = new Date();
            await report.save();
            
            res.json({
                success: true,
                message: `Report sent to ${sentEmails.length} email(s)`,
                sentEmails,
                failedEmails
            });
            
        } catch (error) {
            console.error('Send report email error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to send report email',
                error: error.message
            });
        }
    }
    
    // Generate and send scheduled report (API - for cron jobs)
    static async generateScheduledReport(req, res) {
        try {
            const { type, emails } = req.body;
            
            if (!type || !Object.values(REPORT_TYPES).includes(type)) {
                return res.status(400).json({
                    success: false,
                    message: 'Invalid report type'
                });
            }
            
            // Generate report
            const sensorData = await SensorData.find({
                timestamp: { 
                    $gte: new Date(Date.now() - 24 * 60 * 60 * 1000) // Last 24 hours
                }
            });
            
            if (sensorData.length === 0) {
                return res.status(404).json({
                    success: false,
                    message: 'No data available for report generation'
                });
            }
            
            const now = new Date();
            const startDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1);
            const endDate = new Date(now.getFullYear(), now.getMonth(), now.getDate() - 1, 23, 59, 59);
            
            const reportResult = await ReportGenerator.generateReport(
                sensorData,
                startDate,
                endDate,
                { type, format: 'pdf' }
            );
            
            // Create report document
            const report = new Report({
                title: Report.generateTitle(type, startDate, endDate),
                type,
                period: { startDate, endDate },
                generatedBy: req.session.user.id,
                filePath: reportResult.filePath,
                fileName: reportResult.fileName,
                fileSize: reportResult.fileSize,
                format: reportResult.format,
                summary: reportResult.summary,
                isPublic: true
            });
            
            await report.save();
            
            // Send emails if specified
            if (emails && Array.isArray(emails) && emails.length > 0) {
                try {
                    for (const email of emails) {
                        await EmailService.sendReportEmail(email, reportResult.filePath, type);
                    }
                    
                    report.emailSent = true;
                    report.emailSentTo = emails;
                    report.emailSentAt = new Date();
                    await report.save();
                } catch (emailError) {
                    console.error('Failed to send scheduled report email:', emailError);
                }
            }
            
            res.json({
                success: true,
                message: 'Scheduled report generated successfully',
                data: {
                    reportId: report._id,
                    title: report.title,
                    generatedAt: report.createdAt
                }
            });
            
        } catch (error) {
            console.error('Generate scheduled report error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to generate scheduled report',
                error: error.message
            });
        }
    }
    
    // Get most downloaded reports (API)
    static async getPopularReports(req, res) {
        try {
            const { limit = 10 } = req.query;
            
            const reports = await Report.getMostDownloaded(parseInt(limit));
            
            res.json({
                success: true,
                count: reports.length,
                data: reports
            });
            
        } catch (error) {
            console.error('Get popular reports error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to get popular reports',
                error: error.message
            });
        }
    }
    
    // Clean up old reports (admin only - API)
    static async cleanupOldReports(req, res) {
        try {
            // Check if user is admin
            if (req.session.user.role !== USER_ROLES.ADMIN) {
                return res.status(403).json({
                    success: false,
                    message: 'Access denied. Admin privileges required.'
                });
            }
            
            const { days = 90 } = req.query;
            
            const cutoffDate = new Date();
            cutoffDate.setDate(cutoffDate.getDate() - parseInt(days));
            
            // Find reports older than cutoff
            const oldReports = await Report.find({
                'period.endDate': { $lt: cutoffDate }
            });
            
            let deletedCount = 0;
            let fileDeleteErrors = [];
            
            // Delete files and records
            for (const report of oldReports) {
                try {
                    // Delete file
                    const filePath = path.join(__dirname, '../../', report.filePath);
                    if (fs.existsSync(filePath)) {
                        fs.unlinkSync(filePath);
                    }
                    
                    // Delete record
                    await report.deleteOne();
                    deletedCount++;
                } catch (error) {
                    fileDeleteErrors.push({
                        reportId: report._id,
                        fileName: report.fileName,
                        error: error.message
                    });
                }
            }
            
            res.json({
                success: true,
                message: `Cleaned up ${deletedCount} reports older than ${days} days`,
                deletedCount,
                errors: fileDeleteErrors
            });
            
        } catch (error) {
            console.error('Cleanup old reports error:', error);
            res.status(500).json({
                success: false,
                message: 'Failed to cleanup old reports',
                error: error.message
            });
        }
    }
}

module.exports = ReportController;